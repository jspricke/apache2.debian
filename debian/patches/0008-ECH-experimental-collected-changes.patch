From: Stephen Farrell <stephen.farrell@cs.tcd.ie>
Date: Fri, 24 Nov 2023 13:57:25 +0000
Subject: ECH experimental collected changes

---
 modules/ssl/mod_ssl.c           |   5 ++
 modules/ssl/ssl_engine_config.c |  21 +++++
 modules/ssl/ssl_engine_init.c   | 193 +++++++++++++++++++++++++++++++++++++++-
 modules/ssl/ssl_engine_kernel.c |  93 ++++++++++++++++++-
 modules/ssl/ssl_engine_log.c    |   4 +
 modules/ssl/ssl_private.h       |  17 ++++
 6 files changed, 331 insertions(+), 2 deletions(-)

diff --git a/modules/ssl/mod_ssl.c b/modules/ssl/mod_ssl.c
index 5b8c4d5..51c7b5d 100644
--- a/modules/ssl/mod_ssl.c
+++ b/modules/ssl/mod_ssl.c
@@ -109,6 +109,11 @@ static const command_rec ssl_config_cmds[] = {
     SSL_CMD_SRV(SessionTicketKeyFile, TAKE1,
                 "TLS session ticket encryption/decryption key file (RFC 5077) "
                 "('/path/to/file' - file with 48 bytes of random data)")
+#endif
+#ifdef HAVE_OPENSSL_ECH
+    SSL_CMD_SRV(ECHKeyDir, TAKE1,
+                "TLS ECH Key Directory"
+                "('/path/to/dir' - directory with ECH key pairs)")
 #endif
     SSL_CMD_ALL(CACertificatePath, TAKE1,
                 "SSL CA Certificate path "
diff --git a/modules/ssl/ssl_engine_config.c b/modules/ssl/ssl_engine_config.c
index de18b8f..80376a9 100644
--- a/modules/ssl/ssl_engine_config.c
+++ b/modules/ssl/ssl_engine_config.c
@@ -231,6 +231,9 @@ static SSLSrvConfigRec *ssl_config_server_new(apr_pool_t *p)
     sc->compression            = UNSET;
 #endif
     sc->session_tickets        = UNSET;
+#ifdef HAVE_OPENSSL_ECH
+    sc->echkeydir             = NULL;
+#endif
 
     modssl_ctx_init_server(sc, p);
 
@@ -403,6 +406,9 @@ void *ssl_config_server_merge(apr_pool_t *p, void *basev, void *addv)
     cfgMergeBool(compression);
 #endif
     cfgMergeBool(session_tickets);
+#ifdef HAVE_OPENSSL_ECH
+    cfgMergeString(echkeydir);
+#endif
 
     modssl_ctx_cfg_merge_server(p, base->server, add->server, mrg->server);
 
@@ -743,6 +749,21 @@ const char *ssl_cmd_SSLEngine(cmd_parms *cmd, void *dcfg, const char *arg)
     return "Argument must be On, Off, or Optional";
 }
 
+#ifdef HAVE_OPENSSL_ECH
+const char *ssl_cmd_SSLECHKeyDir(cmd_parms *cmd, void *dcfg, const char *arg)
+{
+    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
+    const char *err;
+
+    sc->echkeydir=arg;
+    ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, cmd->server, APLOGNO(10226)
+                 "%s: ECHKeyDir set to %s",
+                 cmd->cmd->name, sc->echkeydir);
+
+    return NULL;
+}
+#endif
+
 const char *ssl_cmd_SSLFIPS(cmd_parms *cmd, void *dcfg, int flag)
 {
 #ifdef HAVE_FIPS
diff --git a/modules/ssl/ssl_engine_init.c b/modules/ssl/ssl_engine_init.c
index e5d8f68..eb6e1e8 100644
--- a/modules/ssl/ssl_engine_init.c
+++ b/modules/ssl/ssl_engine_init.c
@@ -32,6 +32,14 @@
 #include "mpm_common.h"
 #include "mod_md.h"
 
+#ifdef HAVE_OPENSSL_ECH
+/* TODO: use ap_* portable functions */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <openssl/ech.h>
+#endif
+
 static apr_status_t ssl_init_ca_cert_path(server_rec *, apr_pool_t *, const char *,
                                           STACK_OF(X509_NAME) *, STACK_OF(X509_INFO) *);
 
@@ -187,6 +195,103 @@ static void ssl_add_version_components(apr_pool_t *ptemp, apr_pool_t *pconf,
                  modver, AP_SERVER_BASEVERSION, incver);
 }
 
+#ifdef HAVE_OPENSSL_ECH
+/* 
+ * load any key files we find in the ECHKeyDir directory 
+ * where there are matching <name>.pub and <name>.priv files
+ * that match 
+ */
+static int load_echkeys(SSL_CTX *ctx, const char *echdir, server_rec *s, apr_pool_t *ptemp)
+{
+    /*
+     * Try load any good looking public/private ECH values found in files in that directory
+     *
+     * This code is derived from what I added to openssl s_server, which you can find
+     * in apps/s_server.c in my openssl fork, https://github.com/sftcd/openssl
+     */
+    if (echdir==NULL) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10254)
+                "load_echkeys: no directory name - exiting");
+        return -1;
+    }
+    size_t elen=strlen(echdir);
+    if ((elen+7) >= PATH_MAX) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10255)
+                "load_echkeys: directory name too long: %s - exiting",echdir);
+        return -1;
+    }
+    int keystried=0;
+    int keysworked=0;
+
+    apr_dir_t *dir;
+    apr_finfo_t direntry;
+    apr_int32_t finfo_flags = APR_FINFO_TYPE|APR_FINFO_NAME;
+
+    if (!echdir || (apr_dir_open(&dir, echdir, ptemp) != APR_SUCCESS)) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10258)
+                "load_echkeys: can't open directory %s - exiting",echdir);
+        return -1;
+    }
+
+    while ((apr_dir_read(&direntry, finfo_flags, dir)) == APR_SUCCESS) {
+        const char *fname;
+        if (direntry.filetype == APR_DIR) {
+            continue; /* don't try to load directories */
+        }
+        fname = apr_pstrcat(ptemp, echdir, "/", direntry.name, NULL);
+        /*
+         * If file name matches "*.ech" then try load that 
+         */
+        if (!fname) {
+            continue;
+        }
+        size_t pnlen=strlen(fname);
+        if (pnlen<5 || pnlen>PATH_MAX-1) {
+            continue;
+        }
+        if (!(fname[pnlen-4]=='.'
+            && fname[pnlen-3]=='e'
+            && fname[pnlen-2]=='c'
+            && fname[pnlen-1]=='h')) {
+            continue;
+        }
+        /* should likely use apr_stat instead */
+        struct stat thestat;
+        apr_finfo_t theinfo;
+        if ( (apr_stat (&theinfo, fname, APR_FINFO_MIN, ptemp)==APR_SUCCESS) ) {
+            keystried++;
+            if (SSL_CTX_ech_server_enable_file(ctx, fname,
+                                               SSL_ECH_USE_FOR_RETRY) != 1) {
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(10230)
+                    "load_echkeys: failed for %s (could be non-fatal)",fname);
+            } else {
+                ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, s, APLOGNO(10231)
+                    "load_echkeys: worked for %s",fname);
+                keysworked++;
+            }
+        }
+
+    }
+    apr_dir_close(dir);
+
+    int keysloaded=0;
+    if (!SSL_CTX_ech_server_get_key_status(ctx,&keysloaded)) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10232)
+            "SSL_CTX_ech_server_key_status failed - exiting");
+        return -1;
+    }
+    if (keysworked==0) {
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(10249)
+            "load_echkeys: didn't load new keys (%d tried/failed) but we have already some (%d) - continuing",
+            keystried,keysloaded);
+    } else {
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(10259)
+            "ECH: %d keys loaded", keysloaded);
+    }
+    return 0;
+}
+#endif
+
 /*  _________________________________________________________________
 **
 **  Let other answer special connection attempts. 
@@ -304,6 +409,7 @@ apr_status_t ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
         if (sc->server && sc->server->pphrase_dialog_type == SSL_PPTYPE_UNSET) {
             sc->server->pphrase_dialog_type = SSL_PPTYPE_BUILTIN;
         }
+
     }
 
 #if APR_HAS_THREADS && MODSSL_USE_OPENSSL_PRE_1_1_API
@@ -548,8 +654,20 @@ static apr_status_t ssl_init_ctx_tls_extensions(server_rec *s,
      * protocol version(s) according to the selected (name-based-)vhost, which
      * is not possible at the SNI callback stage (due to OpenSSL internals).
      */
+#ifdef HAVE_OPENSSL_ECH
+    SSLSrvConfigRec *sc = mySrvConfig(s);
+    if (sc!=NULL && sc->echkeydir!=NULL) {
+        SSL_CTX_ech_set_callback(mctx->ssl_ctx, ssl_callback_ECH);
+    } else {
+        ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, s, APLOGNO(10253)
+            "ECHKeyDir not set - using ClientHello callback for SNI");
+        SSL_CTX_set_client_hello_cb(mctx->ssl_ctx, ssl_callback_ClientHello, NULL);
+    }
+
+#else
     SSL_CTX_set_client_hello_cb(mctx->ssl_ctx, ssl_callback_ClientHello, NULL);
 #endif
+#endif
 
 #ifdef HAVE_OCSP_STAPLING
     /*
@@ -841,7 +959,40 @@ static apr_status_t ssl_init_ctx_protocol(server_rec *s,
         SSL_CTX_set_options(ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);
     }
 #endif
-    
+
+#ifdef HAVE_OPENSSL_ECH
+#if SSL_HAVE_PROTOCOL_TLSV1_3
+
+    /* ECH only really makes sense for TLSv1.3 */
+    prot=SSL_CTX_get_max_proto_version(ctx);
+    if (sc->echkeydir) {
+        if (prot == TLS1_3_VERSION) {
+            /* try load the keys */
+            int rv=load_echkeys(ctx,sc->echkeydir,s,ptemp);
+            if (rv!=0) {
+                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10233)
+                    "ECHKeyDir failed to load keys - exiting");
+                SSL_CTX_free(ctx);
+                mctx->ssl_ctx = NULL;
+                return ssl_die(s);
+            }
+        } else {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10228)
+                 "ECHKeyDir configured but TLSv1.3 turned off - exiting.");
+            SSL_CTX_free(ctx);
+            mctx->ssl_ctx = NULL;
+            return ssl_die(s);
+        } 
+    }
+
+#else
+    if (sc->echkeydir) {
+        ap_log_error(APLOG_MARK, APLOG_WARN, 0, s, APLOGNO(10229)
+                 "ECHKeyDir configured but no TLSv1.3 so ECH will be ignored.");
+    }
+#endif
+#endif
+
     return APR_SUCCESS;
 }
 
@@ -939,8 +1090,32 @@ static apr_status_t ssl_init_ctx_verify(server_rec *s,
         ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, s,
                      "Configuring client authentication");
 
+#ifdef HAVE_OPENSSL_ESNI
+
+        if (!SSL_CTX_load_verify_file(ctx,
+                                           mctx->auth.ca_cert_file))
+        {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10234)
+                    "Unable to configure verify CA file "
+                    "for client authentication");
+            ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
+            return ssl_die(s);
+        }
+
+        if (!SSL_CTX_load_verify_dir(ctx,
+                                           mctx->auth.ca_cert_path))
+        {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10235)
+                    "Unable to configure verify CA dir "
+                    "for client authentication");
+            ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
+            return ssl_die(s);
+        }
+
+#else
         if (!modssl_CTX_load_verify_locations(ctx, mctx->auth.ca_cert_file,
                                                    mctx->auth.ca_cert_path)) {
+
             ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01895)
                     "Unable to configure verify locations "
                     "for client authentication");
@@ -948,6 +1123,8 @@ static apr_status_t ssl_init_ctx_verify(server_rec *s,
             return ssl_die(s);
         }
 
+#endif
+
         if (mctx->pks && (mctx->pks->ca_name_file || mctx->pks->ca_name_path)) {
             ca_list = ssl_init_FindCAList(s, ptemp,
                                           mctx->pks->ca_name_file,
@@ -1080,6 +1257,15 @@ static apr_status_t ssl_init_ctx_crl(server_rec *s,
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01900)
                  "Configuring certificate revocation facility");
 
+#ifdef HAVE_OPENSSL_ESNI
+    if (!store || !X509_STORE_load_file(store, mctx->crl_file)) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(10236)
+                     "Host %s: unable to configure X.509 CRL storage "
+                     "for certificate revocation", mctx->sc->vhost_id);
+        ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
+        return ssl_die(s);
+    }
+#else
     if (!store || !modssl_X509_STORE_load_locations(store, mctx->crl_file,
                                                            mctx->crl_path)) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01901)
@@ -1088,6 +1274,7 @@ static apr_status_t ssl_init_ctx_crl(server_rec *s,
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
         return ssl_die(s);
     }
+#endif
 
     switch (crl_check_mode) {
        case SSL_CRLCHECK_LEAF:
@@ -1768,7 +1955,11 @@ static apr_status_t ssl_init_proxy_certs(server_rec *s,
         return ssl_die(s);
     }
 
+#ifdef HAVE_OPENSSL_ESNI
+    X509_STORE_load_file(store, pkp->ca_cert_file);
+#else
     modssl_X509_STORE_load_locations(store, pkp->ca_cert_file, NULL);
+#endif
 
     for (n = 0; n < ncerts; n++) {
         int i;
diff --git a/modules/ssl/ssl_engine_kernel.c b/modules/ssl/ssl_engine_kernel.c
index 591f6ae..24bff77 100644
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -33,6 +33,10 @@
 #include "util_md5.h"
 #include "scoreboard.h"
 
+#ifdef HAVE_OPENSSL_ECH
+#include <openssl/ech.h>
+#endif
+
 static void ssl_configure_env(request_rec *r, SSLConnRec *sslconn);
 #ifdef HAVE_TLSEXT
 static int ssl_find_vhost(void *servername, conn_rec *c, server_rec *s);
@@ -1552,6 +1556,37 @@ int ssl_hook_Fixup(request_rec *r)
     }
 #endif
 
+#ifdef HAVE_OPENSSL_ECH
+    /*
+     * Add the ECH information to the environment 
+     */
+    char *inner_sni=NULL;
+    char *outer_sni=NULL;
+    char buf[PATH_MAX];
+    memset(buf,0,PATH_MAX);
+    int echrv=SSL_ech_get_status((SSL*)ssl,&inner_sni,&outer_sni);
+    switch (echrv) {
+    case SSL_ECH_STATUS_NOT_TRIED:
+        snprintf(buf,PATH_MAX,"not attempted");
+        break;
+    case SSL_ECH_STATUS_FAILED:
+        snprintf(buf,PATH_MAX,"tried but failed");
+        break;
+    case SSL_ECH_STATUS_BAD_NAME:
+        snprintf(buf,PATH_MAX,"ECH worked but bad name");
+        break;
+    case SSL_ECH_STATUS_SUCCESS:
+        snprintf(buf,PATH_MAX,"success");
+        break;
+    default:
+        snprintf(buf,PATH_MAX, "error getting ECH status");
+    }
+    apr_table_set(env, "SSL_ECH_INNER_SNI", (inner_sni?inner_sni:"NONE"));
+    apr_table_set(env, "SSL_ECH_OUTER_SNI", (outer_sni?outer_sni:"NONE"));
+    apr_table_set(env, "SSL_ECH_STATUS", buf);
+
+#endif
+
     /* standard SSL environment variables */
     if (dc->nOptions & SSL_OPT_STDENVVARS) {
         modssl_var_extract_dns(env, ssl, r->pool);
@@ -2431,6 +2466,51 @@ static apr_status_t init_vhost(conn_rec *c, SSL *ssl, const char *servername)
     return APR_NOTFOUND;
 }
 
+#ifdef HAVE_OPENSSL_ECH
+unsigned int ssl_callback_ECH(SSL *ssl, const char *str)  
+{
+    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
+    const char *ech_servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+    if (ech_servername == NULL) {
+        return SSL_TLSEXT_ERR_NOACK;
+    }
+
+    char *inner_sni=NULL;
+    char *outer_sni=NULL;
+    int echrv=SSL_ech_get_status((SSL*)ssl,&inner_sni,&outer_sni);
+    switch (echrv) {
+    case SSL_ECH_STATUS_NOT_TRIED:
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10237)
+            "ECH not attempted");
+        break;
+    case SSL_ECH_STATUS_FAILED:
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10238)
+            "ECH tried but failed");
+        break;
+    case SSL_ECH_STATUS_BAD_NAME:
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10239)
+            "ECH worked but bad name");
+        break;
+    case SSL_ECH_STATUS_SUCCESS:
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10240)
+                "ECH success outer_sni: %s inner_sni: %s",(outer_sni?outer_sni:"NONE"),(inner_sni?inner_sni:"NONE"));
+        break;
+    default:
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10241)
+            "Error getting ECH status");
+    }
+
+    /* try init vhost and see what breaks */
+    apr_status_t ivstatus=init_vhost(c, ssl, ech_servername);
+    if (ivstatus!=APR_SUCCESS) {
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10247)
+                      "init_vhost failed for %s",ech_servername);
+        return SSL_TLSEXT_ERR_NOACK;
+    }
+    return 1;
+}
+#endif
+
 /*
  * This callback function is executed when OpenSSL encounters an extended
  * client hello with a server name indication extension ("SNI", cf. RFC 6066).
@@ -2454,7 +2534,18 @@ int ssl_callback_ClientHello(SSL *ssl, int *al, void *arg)
     const unsigned char *pos;
     size_t len, remaining;
     (void)arg;
- 
+
+#ifdef HAVE_OPENSSL_ECH
+
+    if (SSL_client_hello_get0_ext(ssl, TLSEXT_TYPE_ech13, &pos, &remaining)) {
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10243)
+                      "there is an ECH extension");
+    } else {
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(10244)
+                      "there is NO ECH extension");
+    }
+#endif
+
     /* We can't use SSL_get_servername() at this earliest OpenSSL connection
      * stage, and there is no SSL_client_hello_get0_servername() provided as
      * of OpenSSL 1.1.1. So the code below, that extracts the SNI from the
diff --git a/modules/ssl/ssl_engine_log.c b/modules/ssl/ssl_engine_log.c
index 3b3ceac..1d2c63d 100644
--- a/modules/ssl/ssl_engine_log.c
+++ b/modules/ssl/ssl_engine_log.c
@@ -97,7 +97,11 @@ void ssl_log_ssl_error(const char *file, int line, int level, server_rec *s)
     const char *data;
     int flags;
 
+#ifdef HAVE_OPENSSL_ESNI
+    while ((e=ERR_peek_last_error_data(&data, &flags))) {
+#else
     while ((e = modssl_ERR_peek_error_data(&data, &flags))) {
+#endif
         const char *annotation;
         char err[256];
 
diff --git a/modules/ssl/ssl_private.h b/modules/ssl/ssl_private.h
index cd8df07..89d2b40 100644
--- a/modules/ssl/ssl_private.h
+++ b/modules/ssl/ssl_private.h
@@ -110,6 +110,14 @@
 #include <openssl/engine.h>
 #endif
 
+/*
+ * Check if we have an ECH-enabled OpenSSL 
+ * If we do then this symbol will be defined in ssl.h
+ */
+#if defined(SSL_OP_ECH_GREASE)
+#define HAVE_OPENSSL_ECH
+#endif
+
 #if (OPENSSL_VERSION_NUMBER < 0x0090801f)
 #error mod_ssl requires OpenSSL 0.9.8a or later
 #endif
@@ -802,6 +810,9 @@ struct SSLSrvConfigRec {
     BOOL             compression;
 #endif
     BOOL             session_tickets;
+#ifdef HAVE_OPENSSL_ECH
+    const char *echkeydir;
+#endif
 };
 
 /**
@@ -847,6 +858,9 @@ const char  *ssl_cmd_SSLPassPhraseDialog(cmd_parms *, void *, const char *);
 const char  *ssl_cmd_SSLCryptoDevice(cmd_parms *, void *, const char *);
 const char  *ssl_cmd_SSLRandomSeed(cmd_parms *, void *, const char *, const char *, const char *);
 const char  *ssl_cmd_SSLEngine(cmd_parms *, void *, const char *);
+#ifdef HAVE_OPENSSL_ECH
+const char  *ssl_cmd_SSLECHKeyDir(cmd_parms *cmd, void *dcfg, const char *arg);
+#endif
 const char  *ssl_cmd_SSLCipherSuite(cmd_parms *, void *, const char *, const char *);
 const char  *ssl_cmd_SSLCertificateFile(cmd_parms *, void *, const char *);
 const char  *ssl_cmd_SSLCertificateKeyFile(cmd_parms *, void *, const char *);
@@ -960,6 +974,9 @@ int          ssl_callback_ServerNameIndication(SSL *, int *, modssl_ctx_t *);
 #endif
 #if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(LIBRESSL_VERSION_NUMBER)
 int          ssl_callback_ClientHello(SSL *, int *, void *);
+#ifdef HAVE_OPENSSL_ECH
+unsigned int ssl_callback_ECH(SSL *, const char *);
+#endif
 #endif
 #ifdef HAVE_TLS_SESSION_TICKETS
 int ssl_callback_SessionTicket(SSL *ssl,
